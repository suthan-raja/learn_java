
                                                    Algorithms

1. Time Complexity

        1.1 Array :

            1.1.1 Read , Write , Update :

                It takes a same time for read , write and update in array this is takes constant time so time

                complexity is O(1).

            1.1.2 Insert :

                It takes base on inputs we take worst case if totally 10 records if i insert 2nd place it moves all

                records and insert that value in 2nd place so its time is linear time based on records and time

                complexity is O(n).

            1.1.3 Delete :

                Same as Insert .

            1.1.4 Search :

                Same as Insert based on records we take worst case we want to search last record its time in linear based

                on total records so time complexity is O(n).




2. Searching Algorithm

    2.1 Linear Search

        A linear search algorithm checks each element of a collection one by one until the desired element is found.

        It's simple but inefficient for large datasets, with a time complexity of O(n), where n is the number of elements.

    2.2 Binary Search


        Binary Search is an efficient algorithm used to find the position of a target element in a sorted array.

        The idea behind binary search is to repeatedly divide the search interval in half. If the value of the search

        key is less than the item in the middle of the interval; the search continues in the lower half, otherwise.

        It continues in the upper half. This process is repeated until the target value is found or the search interval

        it is empty.

        2.2.1 How it works:

            The algorithm starts by checking the middle element of the sorted array.

            If the middle element is equal to the target, it returns the index.

            If the middle element is larger than the target, it repeats the process in the left half.

            If the middle element is smaller than the target, it repeats the process in the right half.

            The process continues until the element is found or the search space is exhausted.

------------------------------------------------------------------------------------------------------------------------

3. Sorting Algorithm

    3.1 Bubble Sort

        Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements.

        And swap them if they are in the wrong order. This process is repeated until the list is sorted.

        Pros:

            * Simple to implement.

            * Efficient for small datasets or nearly sorted arrays.

        Cons:

            * Very slow on large datasets; worst-case and average time complexity is O(n²).

            * Poor efficiency for large unsorted data.


    3.2 Selection Sort

        Selection sort works by repeatedly finding minimum element from the unsorted part of the list and putting it

        at the beginning.

        Pros:

            Simple to understand and implement.

            Doesn't require much swapping, O(n) swaps.

        Cons:

            Inefficient for large datasets; time complexity is O(n²).

            Doesn't adapt well to already sorted data.


    3.3 Insertion Sort

        Insertion Sort works by building a sorted array one item at a time, taking one unsorted element, and inserting

        it into its correct position in the sorted portion.

        Pros:

            Efficient for small datasets or nearly sorted data (adaptive).

            Simple to implement, especially for linked lists.

        Cons:

            Time complexity is O(n²) in the worst case.

            Poor performance for large datasets.


    3.4 Merge Sort

        Overview

            Type: Divide and Conquer

            Stability: Stable (preserves the relative order of equal elements)

            Complexity:

                Time: O(n log n) in all cases (best, average, worst)

                Space: O(n) due to temporary arrays

            How It Works

                Divide: Split the array into two halves until each sub-array contains a single element (base case).

                Conquer: Recursively sort both halves.

                Combine: Merge the sorted halves into a single sorted array. This involves comparing the elements of the two halves and putting them in the correct order.

            Advantages

                Predictable O(n log n) performance.

                Good for large datasets and linked lists.

                Works well with external sorting (sorting data that doesn't fit into memory).

            Disadvantages

                Requires additional space for the temporary arrays.

                Slower in practice for smaller datasets compared to other algorithms like Quick Sort.

    3.5 Quick Sort

        overview

            Type: Divide and Conquer

            Stability: Unstable (the relative order of equal elements may not be preserved)

        Complexity:

            Time: O(n log n) on average, O(n²) in the worst case (e.g., when the smallest or largest element is always chosen as the pivot).

            Space: O(log n) due to recursion stack space.

        How It Works

            Choose a Pivot: Select an element from the array (commonly the last element).

            Partition: Rearrange the array so that elements less than the pivot come before it and elements greater come after it. The pivot is now in its final position.

            Recursively Apply: Apply the same process to the sub-arrays formed by the pivot.

        Advantages

            Generally faster in practice than other O(n log n) algorithms like Merge Sort, especially for in-memory sorting.

            Low space complexity compared to Merge Sort.

        Disadvantages

            Worst-case performance of O(n²) can occur without proper pivot selection (e.g., using the first or last element in a sorted or nearly sorted array).

            Not stable by default.

        Comparison

            Stability: Merge Sort is stable, Quick Sort is not.

            Space Complexity: Merge Sort uses more space due to its need for temporary arrays, while Quick Sort can be done in place.

            Performance: Quick Sort tends to be faster in practice due to better cache performance, despite its worst-case scenario.

            These characteristics make both algorithms suitable for different scenarios and types of data.


------------------------------------------------------------------------------------------------------------------------












