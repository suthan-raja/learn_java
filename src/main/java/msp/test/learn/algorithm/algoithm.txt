
                                                    Algorithms

1. Time Complexity

        1.1 Array :

            1.1.1 Read , Write , Update :

                It takes a same time for read , write and update in array this is takes constant time so time

                complexity is O(1).

            1.1.2 Insert :

                It takes base on inputs we takes worst case if totally 10 records if i insert 2nd place it moves all

                records and insert that value in 2nd place so its time is linear time based on records and time

                complexity is O(n).

            1.1.3 Delete :

                Same as Insert .

            1.1.4 Search :

                Same as Insert based on records we take worst case we want to search last record its time in linear based

                on total records so time complexity is O(n).




2. Searching Algorithm

    2.1 Linear Search

        A linear search algorithm checks each element of a collection one by one until the desired element is found.

        It's simple but inefficient for large datasets, with a time complexity of O(n), where n is the number of elements.

    2.2 Binary Search


        Binary Search is an efficient algorithm used to find the position of a target element in a sorted array.

        The idea behind binary search is to repeatedly divide the search interval in half. If the value of the search

        key is less than the item in the middle of the interval, the search continues in the lower half, otherwise,

        it continues in the upper half. This process is repeated until the target value is found or the search interval

        is empty.

        2.2.1 How it works:

            The algorithm starts by checking the middle element of the sorted array.

            If the middle element is equal to the target, it returns the index.

            If the middle element is larger than the target, it repeats the process in the left half.

            If the middle element is smaller than the target, it repeats the process in the right half.

            The process continues until the element is found or the search space is exhausted.

------------------------------------------------------------------------------------------------------------------------

3. Sorting Algorithm

    3.1 Bubble Sort

        Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements,

        and swaps them if they are in the wrong order. This process is repeated until the list is sorted.

        Pros:

            * Simple to implement.

            * Efficient for small datasets or nearly sorted arrays.

        Cons:

            * Very slow on large datasets; worst-case and average time complexity is O(n²).

            * Poor efficiency for large unsorted data.


    3.2 Selection Sort

        Selection sort works by repeatedly finding minimum element from the unsorted part of the list and putting it

        at the beginning.

        Pros:

            Simple to understand and implement.

            Doesn't require much swapping, O(n) swaps.

        Cons:

            Inefficient for large datasets; time complexity is O(n²).

            Doesn't adapt well to already sorted data.










